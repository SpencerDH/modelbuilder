#' Create a stochastic compartmental simulation model
#'
#' This function takes as input a modelbuilder model and writes code
#' for a stochastic simulator function implemented with adaptivetau
#'
#' @description The model needs to adhere to the structure specified by the modelbuilder package
#' models built using the modelbuilder package automatically have the right structure
#' a user can also build a model list structure themselves following the specifications
#' if the user provides an Rdata file name, this file needs to contain an object called 'model'
#' and contain a valid modelbuilder model structure
#' @param model model structure, either as list object or Rdata file name
#' @param location a path/folder to save the simulation code to. Default is current directory
#' @return The function does not return anything
#' Instead, it writes an R file into the specified directory
#' the name of the file is simulate_model$title_adaptivetau.R
#' @author Andreas Handel
#' @export



generate_stochastic <- function(model, location = NULL)
{
  #if the model is passed in as an Rdata file name, load it
  #otherwise, it is assumed that 'model' is a list structure of the right type
  if(is.character(model)) {load(model)}

  #the name of the function produced by this script is simulate_ + "model title" + "_stochastic.R"
  savepath <- location #default is current directory for saving the R function

  #if location is supplied, that's where the code will be saved to
  # if (!is.null(location)) {savepath = paste0(location,'/',filename)}

  #the name of the function produced by this script is  "model title" + "_stochastic.R"
  nvars = length(model$var)  #number of variables/compartments in model
  npars = length(model$par)  #number of parameters in model
  ntime = length(model$time) #numer of parameters for time
  modeltitle = gsub(" ","_",model$title) #title for model, replacing space with low dash to be used in function and file names
  #text for model description
  #all this should be provided in the model sctructure

  sdesc=paste0("#' ",model$title,"\n#' \n")
  sdesc=paste0(sdesc,"#' ",model$description,"\n#' \n")
  sdesc=paste0(sdesc,"#' @details ",model$details, "\n")
  for (n in 1:nvars)
  {
    sdesc=paste0(sdesc,"#' @param ", model$var[[n]]$varname, ' starting value for ',model$var[[n]]$vartext, "\n")
  }
  sdesc=paste0(sdesc,"#' } \n")
  sdesc=paste0(sdesc,"#' @param pars vector of values for model parameters: \n")
  sdesc=paste0(sdesc,"#' \\itemize{ \n")
  for (n in 1:npars)
  {
    sdesc=paste0(sdesc,"#' @param ", model$par[[n]]$parname," ", model$par[[n]]$partext, "\n")
  }
  sdesc=paste0(sdesc,"#' } \n")
  sdesc=paste0(sdesc,"#' @param times vector of values for model times: \n")
  sdesc=paste0(sdesc,"#' \\itemize{ \n")
  for (n in 1:ntime)
  {
    sdesc=paste0(sdesc,"#' @param ", model$time[[n]]$timename," ", model$time[[n]]$timetext, "\n")
  }


  sdesc=paste0(sdesc,"#' } \n")
  sdesc=paste0(sdesc,"#' @return The function returns the output as a list. \n")
  sdesc=paste0(sdesc,"#' The time-series from the simulation is returned as a dataframe saved as list element \n")
  sdesc=paste0(sdesc,"#' @examples  \n")
  sdesc=paste0(sdesc,"#' # To run the simulation with default parameters:  \n")
  sdesc=paste0(sdesc,"#' result <- simulate_",modeltitle,"_stochastic()", " \n")
  sdesc=paste0(sdesc,"#' @section Warning: ","This function does not perform any error checking. So if you try to do something nonsensical (e.g. have negative values for parameters), the code will likely abort with an error message.", "\n")
  sdesc=paste0(sdesc,"#' @section Model Author: ",model$author, "\n")
  sdesc=paste0(sdesc,"#' @section Model creation date: ",model$date, "\n")
  sdesc=paste0(sdesc,"#' @section Code Author: generated by the \\code{generate_stochastic} function \n")
  sdesc=paste0(sdesc,"#' @section Code creation date: ",Sys.Date(), "\n")
  sdesc=paste0(sdesc,"#' @export \n \n")


  #this creates the lines of code for the main function
  #text for head of main body of function
  varstring = "vars = c("
  varnames = ""
  varnamestring = ""
  varstartvals = ""


  for (n in 1:nvars)
  {
    varstring=paste0(varstring, model$var[[n]]$varname," = ", model$var[[n]]$varval,', ')
    varnamestring=paste0(varnamestring,'"',model$var[[n]]$varname,'",')
    varnames=paste0(varnames,',',model$var[[n]]$varname)
  }

  varnamestring = substr(varnamestring,1,nchar(varnamestring)-1) #trim off final comma
  varstring = substr(varstring,1,nchar(varstring)-2)
  varstring = paste0(varstring,'), ') #close parantheses


  parstring = "pars = c("
  for (n in 1:npars)
  {
    parstring=paste0(parstring, model$par[[n]]$parname," = ", model$par[[n]]$parval,', ')
  }
  parstring = substr(parstring,1,nchar(parstring)-2)
  parstring = paste0(parstring,'), ') #close parantheses

  timestring = "times = c("
  for (n in 1:ntime)
  {
    timestring=paste0(timestring, model$time[[n]]$timename," = ", model$time[[n]]$timeval,', ')
  }
  timestring = substr(timestring,1,nchar(timestring)-2)
  timestring = paste0(timestring,') ') #close parantheses




  ##############################################################################
  #the next block of commands produces the ODE/rate functions required by adaptivetau
  varnames = unlist(sapply(model$var, '[', 1)) #extract variable names as vector
  vartext = unlist(sapply(model$var, '[', 1)) #extract variable text as vector
  allflows = sapply(model$var, '[', 4) #extract flows

  #turns flow list into matrix, adding NA, found it online, not sure how exactly it works
  flowmat = t(sapply(allflows, `length<-`, max(lengths(allflows))))
  flowmatred = sub("\\+|-","",flowmat)   #strip leading +/- from flows
  signmat =  gsub("(\\+|-).*","\\1",flowmat) #extract only the + or - signs from flows so we know the direction

  #creating a dataframe of only the rates
  dfRates = as.data.frame(c(flowmat))

  #deleting "NA"s from the dataframe
  dfRates = na.omit(cbind(rep(varnames, ncol(flowmat)), dfRates))

  #extracting coefficient from the rates/flows
  dfRates$coef = paste(substr(dfRates$`c(flowmat)`,1,1), "1", sep = "")

  #new variable of raw flows with no coefficients
  dfRates$noCoefs = na.omit(c(flowmatred))

  #renaming variables in dataframe
  names(dfRates) = c("variable", "flows", "coefs", "rawFlows")

  #ordering the raw flow rates alphabetically
  dfRates = dfRates[order(dfRates$rawFlows),]

  #count() creates dataframe of raw flows and number of times they occur in the model
  countsFlows = dplyr::count(dfRates, rawFlows)
  rownames(dfRates) = c()

  # ordering flows by number of occurences
  countsFlows1 = countsFlows[order(-countsFlows$n),]

  #removing rownames
  rownames(countsFlows1) = c()

  #rates list for rate function, pasting unique flows separated by a comma
  ratesList = paste(unique(countsFlows1$rawFlows), sep = ",", collapse =", ")


  # this block of code gives all rates/flows specified in the model structure
  sdisc = "  #Block of ODE equations for adaptivetau \n"
  sdisc = paste0(sdisc,"  ", gsub(" ","_",model$title),'_ode <- function(y, parms, t) \n  {\n')
  sdisc = paste0(sdisc,"    with(as.list(c(y,parms)),   \n     { \n")#lets us access variables and parameters stored in y and parms by name
  sdisc = paste0(sdisc,"       #specify each rate/transition/reaction that can happen in the system \n")
  sdisc = paste0(sdisc,"     rates = c(", ratesList, ")", "\n")
  sdisc = paste0(sdisc,"     return(rates) \n      }\n", "\t \t)   \n   } # end function specifying rates used by adaptive tau \n")

  sdisc = paste0(sdisc, "\n ")


  sdisc = paste0(sdisc, "  #specify for each reaction/rate/transition how the different variables change \n")
  sdisc = paste0(sdisc, "  #needs to be in exactly the same order as the rates listed in the rate function \n")


  # this next block of code produces the transitions between compartments required by adaptive tau
  sdisc = paste0(sdisc, "   transitions = list(" )

     #countFlows2 creates df of all raw flows, compartment they go into/out of and corresponding compartment/coefficientle
     countsFlows2 = merge(dfRates, countsFlows1, by.x = "rawFlows", by.y = "rawFlows")

     # sort counts of flows in decreasing order
     countsFlows2 = countsFlows2[order(-countsFlows2$n),]

     # new dataset of only flows where it appears more than once
     countsFlowsGT1 = countsFlows2[which(countsFlows2$n > 1), ]

     # deletes all duplicate flows. we are left with rates that are unique
     uniqueFlows = countsFlows2[!duplicated(countsFlows2$rawFlows), ]

    # if there is only one flow for a compartment, paste that transition (compartment 1 to comparment 2)
     # otherwise, replace with NA
     uniqueFlows$trans = ifelse(uniqueFlows$n == 1 , paste0("c(", uniqueFlows$variable, " = ", uniqueFlows$coefs, ")"), "NA")



     # in dataframe where rates that appear more than once, read every other line
     #  extract coefficient of those rates from the first compartment to the next in "trans" variable
     # if line not read by loop, replace it by a NA

     for (i in seq(from = 1, to = nrow(countsFlowsGT1)-1, by = 2)){

       countsFlowsGT1$trans[i] = paste0("c(", countsFlowsGT1$variable[i], " = ", countsFlowsGT1$coefs[i], ",",
                                        countsFlowsGT1$variable[i+1], " = ", countsFlowsGT1$coefs[i+1], ")")

       countsFlowsGT1$trans[i+1] = NA

     }


    # sort the unique flows in decreasing number of appearence
     uniqueFlows = uniqueFlows[order(-uniqueFlows$n), ]

     # take lines where data was read in for loop in countsFlowsGT1 (every other line)
     # and replaces NA's in unique FLow

     uniqueFlows$trans = ifelse(uniqueFlows$trans == "NA", countsFlowsGT1$trans[c(T,F)], uniqueFlows$trans)

    # printing all trans in uniqueFlows separated by a comma
    transitionList = paste(uniqueFlows$trans, sep = ", \n \t \t \t\t\t\t", collapse =", \n \t \t \t\t\t\t")


  sdisc = paste0(sdisc, transitionList, ")")

  #finish block that creates the ODE function-----------------------------



  stitle = paste0("simulate_",modeltitle,"_stochastic <- function(",varstring, parstring, timestring,') \n { \n')

  smain = "\n\n"
  smain = paste0(smain,'  #this line runs the simulation using the SSA algorithm in the adaptivetau package \n')
  smain = paste0(smain,'  odeout = adaptivetau::ssa.adaptivetau(init.values = vars, transitions = transitions,
                \t \t \t rateFunc = ',gsub(" ","_",model$title),'_ode, params = pars, tf = times[2]) \n')
  smain = paste0(smain,'  result <- list() \n \n');
  smain = paste0(smain,'  result$ts <- as.data.frame(odeout) \n \n')
  smain = paste0(smain,'  return(result) \n \n')
  smain = paste0(smain,'} \n')
  #finish block that creates main function part
  ##############################################################################

  ##############################################################################
  #write all text blocks to file
  sink(savepath)
  cat(sdesc)
  cat(stitle)
  cat(sdisc)
  cat(smain)
  sink()
}
